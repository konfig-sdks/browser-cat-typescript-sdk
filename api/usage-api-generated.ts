/* tslint:disable */
/* eslint-disable */
/*
BrowserCat API

Providing purr-fect headless browser access via utility endpoints and direct websocket connections.

The version of the OpenAPI document: 1.0.0
Contact: support@browsercat.com

NOTE: This file is auto generated by Konfig (https://konfigthis.com).
*/

import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction, isBrowser } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { UsageBucket } from '../models';
// @ts-ignore
import { UsageEvent } from '../models';
// @ts-ignore
import { UsageGetEventData401Response } from '../models';
// @ts-ignore
import { UsageGetEventData403Response } from '../models';
// @ts-ignore
import { UsageGetEventData404Response } from '../models';
// @ts-ignore
import { UsageGetEventData500Response } from '../models';
// @ts-ignore
import { UsageGetEventDataResponse } from '../models';
// @ts-ignore
import { UsageGetRequestData401Response } from '../models';
// @ts-ignore
import { UsageGetRequestData403Response } from '../models';
// @ts-ignore
import { UsageGetRequestData404Response } from '../models';
// @ts-ignore
import { UsageGetRequestData500Response } from '../models';
// @ts-ignore
import { UsageGetRequestDataResponse } from '../models';
// @ts-ignore
import { UsageGetSessionRange401Response } from '../models';
// @ts-ignore
import { UsageGetSessionRange403Response } from '../models';
// @ts-ignore
import { UsageGetSessionRange500Response } from '../models';
// @ts-ignore
import { UsageGetSessionRangeResponse } from '../models';
// @ts-ignore
import { UsageListAggregateAccountUsage401Response } from '../models';
// @ts-ignore
import { UsageListAggregateAccountUsage403Response } from '../models';
// @ts-ignore
import { UsageListAggregateAccountUsage500Response } from '../models';
// @ts-ignore
import { UsageListAggregateAccountUsageResponse } from '../models';
// @ts-ignore
import { UsageListAggregateAccountUsageUserIdParameterAnyOf } from '../models';
// @ts-ignore
import { UsageListRequestEvents401Response } from '../models';
// @ts-ignore
import { UsageListRequestEvents403Response } from '../models';
// @ts-ignore
import { UsageListRequestEvents500Response } from '../models';
// @ts-ignore
import { UsageListRequestEventsResponse } from '../models';
// @ts-ignore
import { UsageSessionPublic } from '../models';
import { paginate } from "../pagination/paginate";
import type * as buffer from "buffer"
import { requestBeforeHook } from '../requestBeforeHook';
/**
 * UsageApi - axios parameter creator
 * @export
 */
export const UsageApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve a particular event for a request.
         * @summary Retrieve data for an event
         * @param {string} sessionId 
         * @param {string} eventId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventData: async (sessionId: string, eventId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('getEventData', 'sessionId', sessionId)
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('getEventData', 'eventId', eventId)
            const localVarPath = `/usage/sessions/{sessionId}/events/{eventId}`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId !== undefined ? sessionId : `-sessionId-`)))
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId !== undefined ? eventId : `-eventId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtCookie required
            await setApiKeyToObject({object: localVarHeaderParameter, type: "Cookie", key: "Cookie", keyParamName: "__SESSION", configuration})
            // authentication keyHeader required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "Api-Key", keyParamName: "keyHeader", configuration })

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/usage/sessions/{sessionId}/events/{eventId}',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve data for a particular request.
         * @summary Retrieve data for a request
         * @param {string} sessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRequestData: async (sessionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('getRequestData', 'sessionId', sessionId)
            const localVarPath = `/usage/sessions/{sessionId}`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId !== undefined ? sessionId : `-sessionId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtCookie required
            await setApiKeyToObject({object: localVarHeaderParameter, type: "Cookie", key: "Cookie", keyParamName: "__SESSION", configuration})
            // authentication keyHeader required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "Api-Key", keyParamName: "keyHeader", configuration })

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/usage/sessions/{sessionId}',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all sessions within a time range.
         * @summary List sessions within range
         * @param {number} [limit] 
         * @param {any} [offset] 
         * @param {string} [afterDate] 
         * @param {string} [beforeDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessionRange: async (limit?: number, offset?: any, afterDate?: string, beforeDate?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/usage/sessions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtCookie required
            await setApiKeyToObject({object: localVarHeaderParameter, type: "Cookie", key: "Cookie", keyParamName: "__SESSION", configuration})
            // authentication keyHeader required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "Api-Key", keyParamName: "keyHeader", configuration })
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (afterDate !== undefined) {
                localVarQueryParameter['afterDate'] = (afterDate as any instanceof Date) ?
                    (afterDate as any).toISOString() :
                    afterDate;
            }

            if (beforeDate !== undefined) {
                localVarQueryParameter['beforeDate'] = (beforeDate as any instanceof Date) ?
                    (beforeDate as any).toISOString() :
                    beforeDate;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/usage/sessions',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List account usage within a time range.
         * @summary List aggregate account usage
         * @param {number} [limit] 
         * @param {any} [offset] 
         * @param {string} [afterDate] 
         * @param {string} [beforeDate] 
         * @param {'minute' | 'hour' | 'day' | 'week'} [unit] 
         * @param {UsageListAggregateAccountUsageUserIdParameter} [userId] 
         * @param {UsageListAggregateAccountUsageKeyIdParameter} [keyId] 
         * @param {'api' | 'ws'} [method] 
         * @param {string} [endpoint] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAggregateAccountUsage: async (limit?: number, offset?: any, afterDate?: string, beforeDate?: string, unit?: 'minute' | 'hour' | 'day' | 'week', userId?: UsageListAggregateAccountUsageUserIdParameter, keyId?: UsageListAggregateAccountUsageKeyIdParameter, method?: 'api' | 'ws', endpoint?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/usage/buckets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtCookie required
            await setApiKeyToObject({object: localVarHeaderParameter, type: "Cookie", key: "Cookie", keyParamName: "__SESSION", configuration})
            // authentication keyHeader required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "Api-Key", keyParamName: "keyHeader", configuration })
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (afterDate !== undefined) {
                localVarQueryParameter['afterDate'] = (afterDate as any instanceof Date) ?
                    (afterDate as any).toISOString() :
                    afterDate;
            }

            if (beforeDate !== undefined) {
                localVarQueryParameter['beforeDate'] = (beforeDate as any instanceof Date) ?
                    (beforeDate as any).toISOString() :
                    beforeDate;
            }

            if (unit !== undefined) {
                localVarQueryParameter['unit'] = unit;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (keyId !== undefined) {
                localVarQueryParameter['keyId'] = keyId;
            }

            if (method !== undefined) {
                localVarQueryParameter['method'] = method;
            }

            if (endpoint !== undefined) {
                localVarQueryParameter['endpoint'] = endpoint;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/usage/buckets',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all events within a particular request.
         * @summary List events for a request
         * @param {string} sessionId 
         * @param {number} [limit] 
         * @param {any} [offset] 
         * @param {string} [afterDate] 
         * @param {string} [beforeDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRequestEvents: async (sessionId: string, limit?: number, offset?: any, afterDate?: string, beforeDate?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('listRequestEvents', 'sessionId', sessionId)
            const localVarPath = `/usage/sessions/{sessionId}/events`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId !== undefined ? sessionId : `-sessionId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtCookie required
            await setApiKeyToObject({object: localVarHeaderParameter, type: "Cookie", key: "Cookie", keyParamName: "__SESSION", configuration})
            // authentication keyHeader required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "Api-Key", keyParamName: "keyHeader", configuration })
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (afterDate !== undefined) {
                localVarQueryParameter['afterDate'] = (afterDate as any instanceof Date) ?
                    (afterDate as any).toISOString() :
                    afterDate;
            }

            if (beforeDate !== undefined) {
                localVarQueryParameter['beforeDate'] = (beforeDate as any instanceof Date) ?
                    (beforeDate as any).toISOString() :
                    beforeDate;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/usage/sessions/{sessionId}/events',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsageApi - functional programming interface
 * @export
 */
export const UsageApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsageApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve a particular event for a request.
         * @summary Retrieve data for an event
         * @param {UsageApiGetEventDataRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEventData(requestParameters: UsageApiGetEventDataRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsageEvent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEventData(requestParameters.sessionId, requestParameters.eventId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve data for a particular request.
         * @summary Retrieve data for a request
         * @param {UsageApiGetRequestDataRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRequestData(requestParameters: UsageApiGetRequestDataRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsageSessionPublic>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRequestData(requestParameters.sessionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all sessions within a time range.
         * @summary List sessions within range
         * @param {UsageApiGetSessionRangeRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSessionRange(requestParameters: UsageApiGetSessionRangeRequest = {}, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UsageSessionPublic>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSessionRange(requestParameters.limit, requestParameters.offset, requestParameters.afterDate, requestParameters.beforeDate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List account usage within a time range.
         * @summary List aggregate account usage
         * @param {UsageApiListAggregateAccountUsageRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAggregateAccountUsage(requestParameters: UsageApiListAggregateAccountUsageRequest = {}, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UsageBucket>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAggregateAccountUsage(requestParameters.limit, requestParameters.offset, requestParameters.afterDate, requestParameters.beforeDate, requestParameters.unit, requestParameters.userId, requestParameters.keyId, requestParameters.method, requestParameters.endpoint, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all events within a particular request.
         * @summary List events for a request
         * @param {UsageApiListRequestEventsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRequestEvents(requestParameters: UsageApiListRequestEventsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UsageEvent>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRequestEvents(requestParameters.sessionId, requestParameters.limit, requestParameters.offset, requestParameters.afterDate, requestParameters.beforeDate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UsageApi - factory interface
 * @export
 */
export const UsageApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsageApiFp(configuration)
    return {
        /**
         * Retrieve a particular event for a request.
         * @summary Retrieve data for an event
         * @param {UsageApiGetEventDataRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventData(requestParameters: UsageApiGetEventDataRequest, options?: AxiosRequestConfig): AxiosPromise<UsageEvent> {
            return localVarFp.getEventData(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve data for a particular request.
         * @summary Retrieve data for a request
         * @param {UsageApiGetRequestDataRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRequestData(requestParameters: UsageApiGetRequestDataRequest, options?: AxiosRequestConfig): AxiosPromise<UsageSessionPublic> {
            return localVarFp.getRequestData(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * List all sessions within a time range.
         * @summary List sessions within range
         * @param {UsageApiGetSessionRangeRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessionRange(requestParameters: UsageApiGetSessionRangeRequest = {}, options?: AxiosRequestConfig): AxiosPromise<Array<UsageSessionPublic>> {
            return localVarFp.getSessionRange(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * List account usage within a time range.
         * @summary List aggregate account usage
         * @param {UsageApiListAggregateAccountUsageRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAggregateAccountUsage(requestParameters: UsageApiListAggregateAccountUsageRequest = {}, options?: AxiosRequestConfig): AxiosPromise<Array<UsageBucket>> {
            return localVarFp.listAggregateAccountUsage(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * List all events within a particular request.
         * @summary List events for a request
         * @param {UsageApiListRequestEventsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRequestEvents(requestParameters: UsageApiListRequestEventsRequest, options?: AxiosRequestConfig): AxiosPromise<Array<UsageEvent>> {
            return localVarFp.listRequestEvents(requestParameters, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getEventData operation in UsageApi.
 * @export
 * @interface UsageApiGetEventDataRequest
 */
export type UsageApiGetEventDataRequest = {
    
    /**
    * 
    * @type {string}
    * @memberof UsageApiGetEventData
    */
    readonly sessionId: string
    
    /**
    * 
    * @type {string}
    * @memberof UsageApiGetEventData
    */
    readonly eventId: string
    
}

/**
 * Request parameters for getRequestData operation in UsageApi.
 * @export
 * @interface UsageApiGetRequestDataRequest
 */
export type UsageApiGetRequestDataRequest = {
    
    /**
    * 
    * @type {string}
    * @memberof UsageApiGetRequestData
    */
    readonly sessionId: string
    
}

/**
 * Request parameters for getSessionRange operation in UsageApi.
 * @export
 * @interface UsageApiGetSessionRangeRequest
 */
export type UsageApiGetSessionRangeRequest = {
    
    /**
    * 
    * @type {number}
    * @memberof UsageApiGetSessionRange
    */
    readonly limit?: number
    
    /**
    * 
    * @type {any}
    * @memberof UsageApiGetSessionRange
    */
    readonly offset?: any
    
    /**
    * 
    * @type {string}
    * @memberof UsageApiGetSessionRange
    */
    readonly afterDate?: string
    
    /**
    * 
    * @type {string}
    * @memberof UsageApiGetSessionRange
    */
    readonly beforeDate?: string
    
}

/**
 * Request parameters for listAggregateAccountUsage operation in UsageApi.
 * @export
 * @interface UsageApiListAggregateAccountUsageRequest
 */
export type UsageApiListAggregateAccountUsageRequest = {
    
    /**
    * 
    * @type {number}
    * @memberof UsageApiListAggregateAccountUsage
    */
    readonly limit?: number
    
    /**
    * 
    * @type {any}
    * @memberof UsageApiListAggregateAccountUsage
    */
    readonly offset?: any
    
    /**
    * 
    * @type {string}
    * @memberof UsageApiListAggregateAccountUsage
    */
    readonly afterDate?: string
    
    /**
    * 
    * @type {string}
    * @memberof UsageApiListAggregateAccountUsage
    */
    readonly beforeDate?: string
    
    /**
    * 
    * @type {'minute' | 'hour' | 'day' | 'week'}
    * @memberof UsageApiListAggregateAccountUsage
    */
    readonly unit?: 'minute' | 'hour' | 'day' | 'week'
    
    /**
    * 
    * @type {UsageListAggregateAccountUsageUserIdParameter}
    * @memberof UsageApiListAggregateAccountUsage
    */
    readonly userId?: UsageListAggregateAccountUsageUserIdParameter
    
    /**
    * 
    * @type {UsageListAggregateAccountUsageKeyIdParameter}
    * @memberof UsageApiListAggregateAccountUsage
    */
    readonly keyId?: UsageListAggregateAccountUsageKeyIdParameter
    
    /**
    * 
    * @type {'api' | 'ws'}
    * @memberof UsageApiListAggregateAccountUsage
    */
    readonly method?: 'api' | 'ws'
    
    /**
    * 
    * @type {string}
    * @memberof UsageApiListAggregateAccountUsage
    */
    readonly endpoint?: string
    
}

/**
 * Request parameters for listRequestEvents operation in UsageApi.
 * @export
 * @interface UsageApiListRequestEventsRequest
 */
export type UsageApiListRequestEventsRequest = {
    
    /**
    * 
    * @type {string}
    * @memberof UsageApiListRequestEvents
    */
    readonly sessionId: string
    
    /**
    * 
    * @type {number}
    * @memberof UsageApiListRequestEvents
    */
    readonly limit?: number
    
    /**
    * 
    * @type {any}
    * @memberof UsageApiListRequestEvents
    */
    readonly offset?: any
    
    /**
    * 
    * @type {string}
    * @memberof UsageApiListRequestEvents
    */
    readonly afterDate?: string
    
    /**
    * 
    * @type {string}
    * @memberof UsageApiListRequestEvents
    */
    readonly beforeDate?: string
    
}

/**
 * UsageApiGenerated - object-oriented interface
 * @export
 * @class UsageApiGenerated
 * @extends {BaseAPI}
 */
export class UsageApiGenerated extends BaseAPI {
    /**
     * Retrieve a particular event for a request.
     * @summary Retrieve data for an event
     * @param {UsageApiGetEventDataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsageApiGenerated
     */
    public getEventData(requestParameters: UsageApiGetEventDataRequest, options?: AxiosRequestConfig) {
        return UsageApiFp(this.configuration).getEventData(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve data for a particular request.
     * @summary Retrieve data for a request
     * @param {UsageApiGetRequestDataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsageApiGenerated
     */
    public getRequestData(requestParameters: UsageApiGetRequestDataRequest, options?: AxiosRequestConfig) {
        return UsageApiFp(this.configuration).getRequestData(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all sessions within a time range.
     * @summary List sessions within range
     * @param {UsageApiGetSessionRangeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsageApiGenerated
     */
    public getSessionRange(requestParameters: UsageApiGetSessionRangeRequest = {}, options?: AxiosRequestConfig) {
        return UsageApiFp(this.configuration).getSessionRange(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List account usage within a time range.
     * @summary List aggregate account usage
     * @param {UsageApiListAggregateAccountUsageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsageApiGenerated
     */
    public listAggregateAccountUsage(requestParameters: UsageApiListAggregateAccountUsageRequest = {}, options?: AxiosRequestConfig) {
        return UsageApiFp(this.configuration).listAggregateAccountUsage(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all events within a particular request.
     * @summary List events for a request
     * @param {UsageApiListRequestEventsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsageApiGenerated
     */
    public listRequestEvents(requestParameters: UsageApiListRequestEventsRequest, options?: AxiosRequestConfig) {
        return UsageApiFp(this.configuration).listRequestEvents(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }
}
